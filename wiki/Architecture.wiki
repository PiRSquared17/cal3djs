#summary This document explains the architecture of the Cal3DJS library.

= Overview =

The basic concept in the Cal3D library is to separate data that can be shared between several objects from data that is tied to one specific object instance. In the realm of skeletal character animation there is quite a lot of shared data: Take the animations and the meshes as examples

The Cal3D library has a set of [Architecture#Core_Classes Core Classes] that represents one type of model and that stores all the shared data. Each set of [Architecture#Instance_Classes Instance Classes] is constructed from the Core Classes and represents one specific instance of the model type

Say we have a little fantasy game with heroic warriors and deadly dragons. There will be 2 different core models, namely the one for the warriors and the other for the dragons. The core model of the warriors contains all the animations, materials and meshes of all possible warrior instances. The same holds for the dragon core model. Now, every time a warrior or dragon is born, a new model instance will be created based on its core model. The individual appearance is done by selecting specific meshes and materials from the core model. This allows us to have epic battles with numerous different warriors and dragons, even so we store most of the data only once.

== Core Classes ==

As explained, each set of _*Core Classes*_ contains all the data for one model type. This data can be divided into 4 parts: 

 # The hierarchical structure, see Skeletons and Bones for details. 
 # The motion data, see Animations, Tracks and Keyframes for details. 
 # The surface properties, see Materials for details. 
 # The body parts, see Meshes and Submeshes for details.

*Figure 1-1. Core Classes*

http://cal3djs.googlecode.com/svn/wiki/architecture_guide_classes_2.gif

== Instance Classes ==

Each set of Instance Classes contains the specific data for one instance of a model type. This data can be divided into 3 parts: 
 # The current state of the skeleton, see Skeletons and Bones for details.
 # The active set of animations, see Animations, Tracks and Keyframes for details. 
 # The attached body parts, see Meshes and Submeshes for details. 

There are 4 helper classes that simplify the model handling: 
 # The motion control, see The 'Mixer' for details. 
 # The skinning stage (Physique). 
 # The (experimental) cloth animation layer (Spring-System). 
 # The rendering interface, see The 'Renderer' for details. 

*Figure 1-2. Core Classes*

http://cal3djs.googlecode.com/svn/wiki/architecture_guide_classes_3.gif

== Animation Pipeline ==

The process of calculating the final model from the core data and the current instance state must be seen as one single pipeline: 
 # The combination of all the active animations in the "Mixer" to get a current skeleton pose.
 # The combination of all the active morph targets in the "Morpher" to get a current mesh. 
 # The deformation of the current mesh based on the current skeleton pose in the "Physique". 
 # The simulation of the cloth parts of the model in the "Spring-System". 
 # The querying of the final data from the "Renderer". 

*Figure 1-3. Core Classes*

http://cal3djs.googlecode.com/svn/wiki/architecture_guide_pipeline.gif

= Vectors and Quaternions =

Vectors and quaternions are essential elements in the internal calculations of the Cal3D library. The translation of bones, the position of mesh vertices and the orientation of mesh normals are all stored as a vector. Quaternions are used whenever a rotation needs to be represented, such as at a joint. They have some big advantages over rotation matrices in regard to interpolation and memory usage. This is the reason why you will not find any matrices in the Cal3D library. If you ever need these rotations in a matrix representation, you can easily convert the quaternions though. 

= Skeletons and Bones =

The Cal3D library is designed as a skeletal-based animation system. This means that all the mesh vertices of the animated model are attached to one or more bones of an underlying skeleton structure. This makes it very easy to animate the whole model, you only need to adjust the skeleton pose and the model meshes are automatically deformed. This method of attaching meshes to a bone hierarchy is known as 'skinning'. 

*Figure 3-1. Core Classes*